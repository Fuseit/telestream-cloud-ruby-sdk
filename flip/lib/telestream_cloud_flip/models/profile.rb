=begin
#Flip API

#Description

OpenAPI spec version: 2.0.1
Contact: cloudsupport@telestream.net
Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.1

=end

require 'date'

module TelestreamCloud::Flip

  class Profile
    # todo
    attr_accessor :advanced_fps_conversion

    # Specifies an aspect mode for output videos. The following options are available:   - letterbox:   - pad: Add paddings to the input image. Default is \"letterbox\".
    attr_accessor :aspect_mode

    # A display aspect ratio. By default it is not set.
    attr_accessor :aspect_ratio

    # audio bitrate (in bits/s)
    attr_accessor :audio_bitrate

    # A number of audio channels. By default it is not set.
    attr_accessor :audio_channels

    # A channel layout specifies the spatial disposition of the channels in a multi-channel audio stream.
    attr_accessor :audio_channels_layout

    # A number of audio channels per track.
    attr_accessor :audio_channels_per_track

    # Audio codec that will be used by the profile. Available codecs are: `libmp3lame`, `libvorbis`, `libfdk_aac`, `dib_ac3, `pcm_s16le`, `mp2`, `ac3`, `eac3`.
    attr_accessor :audio_codec

    # Specifies an audio container.
    attr_accessor :audio_format

    attr_accessor :audio_map

    # Packet identifier used by MPEG formats.
    attr_accessor :audio_pid

    # Specifies an audio profile.
    attr_accessor :audio_profile

    # The number of samples of audio carried per second.
    attr_accessor :audio_sample_rate

    attr_accessor :audio_stream_id

    # A number of audio streams.
    attr_accessor :audio_streams

    # A class of the AVC-Intra video coding.
    attr_accessor :avcintra_class

    # Determines the size of the PulseAudio buffer. by default it is not set.
    attr_accessor :buffer_size

    # todo
    attr_accessor :buffer_size_in_packets

    attr_accessor :bumpers

    attr_accessor :byte_range_requests

    # Clip ends at a specific time.
    attr_accessor :clip_end

    # A clipâ€™s duration.
    attr_accessor :clip_length

    # Clip starts at a specific offset.
    attr_accessor :clip_offset

    # One of add (adds captions as a separate streams) or burn (burns captions on video stream using the first subtitle file). By default it is not set.
    attr_accessor :closed_captions

    attr_accessor :color_metadata

    # A date and time when the Profile has been created.
    attr_accessor :created_at

    # Distance (in pixels) from the bottom edge of the screen from which you want your crop to be done.
    attr_accessor :crop_input_bottom

    # Width of the cropped image in pixels.
    attr_accessor :crop_input_height

    # Distance (in pixels) from the left edge of the screen from which you want your crop to be done.
    attr_accessor :crop_input_left

    # Distance (in pixels) from the right edge of the screen from which you want your crop to be done.
    attr_accessor :crop_input_right

    # Distance (in pixels) from the top edge of the screen from which you want your crop to be done.
    attr_accessor :crop_input_top

    # Height of the cropped image in pixels.
    attr_accessor :crop_input_width

    attr_accessor :dash_profile

    # One of `keep_fps` or `double_fps`. By default it is not set.
    attr_accessor :deinterlace

    attr_accessor :deinterlace_frames

    # Description of the profile.
    attr_accessor :description

    attr_accessor :dnxhd_type

    attr_accessor :encryption

    # File extension.
    attr_accessor :extname

    # Null value copy the original fps. By default it is not set.
    attr_accessor :fps

    # Evenly spaced number of generated screenshots. By default it is not set.
    attr_accessor :frame_count

    # Thumbnail interval (Frames or seconds).
    attr_accessor :frame_interval

    # Array of offsets (Frames or seconds).
    attr_accessor :frame_offsets

    # A specified set of constraints that indicate a degree of required decoder performance for a profile.
    attr_accessor :h264_level

    # Profiles represent a sub-set of the encoding techniques available in H.264.
    attr_accessor :h264_profile

    # Specifies a h264 tuning option.
    attr_accessor :h264_tune

    # Height in pixels.
    attr_accessor :height

    attr_accessor :id

    attr_accessor :imx_type

    attr_accessor :inputs

    attr_accessor :interlace

    # Adds a key frame every N frames. Default is 250, adds a key frame every 250 frames.
    attr_accessor :keyframe_interval

    # todo
    attr_accessor :keyframe_rate

    attr_accessor :lang

    # A max bitrate tolerance (in bits/s). By default this is not set.
    attr_accessor :max_rate

    attr_accessor :merge_audio_streams

    # Remove audio from input video file. By default it is set to `false`.
    attr_accessor :mute_audio_tracks

    # A unique machine-readable name that will identify the profile. Helpful later on for filtering encodings by profile.
    attr_accessor :name

    attr_accessor :outputs

    # Specify the directory where the output files should be stored. By default it is not set. More information about this [here](https://cloud.telestream.net/docs#path-format---know-how).
    attr_accessor :outputs_path_format

    attr_accessor :playlist_type

    attr_accessor :pmt_pid

    # a name of a preset that a profile will use.
    attr_accessor :preset_name

    attr_accessor :prores_format

    # Minimum value is 2, maximum is 60.
    attr_accessor :segment_time

    attr_accessor :stack

    attr_accessor :telestream_block_size

    # Minimum value is 0, maximum is 4.
    attr_accessor :telestream_blur_scaler

    # Minimum value is 0, maximum is 4.
    attr_accessor :telestream_cost_scaler

    # Minimum value is 0, maximum is 2.
    attr_accessor :telestream_search_length_scaler

    attr_accessor :telestream_subpel_mode

    # If set, timestamps will be added to your videos. By default this is not set.
    attr_accessor :time_code

    # Human-readable name.
    attr_accessor :title

    attr_accessor :trailers

    attr_accessor :transport_rate

    attr_accessor :ts_pids

    attr_accessor :updated_at

    # Upscale the video resolution to match your profile. Default is `true`.
    attr_accessor :upscale

    attr_accessor :use_editlist

    # Pattern utilised to match HLS.Variant presets by name. Default is hls.*.
    attr_accessor :variants

    attr_accessor :video_bitrate

    attr_accessor :video_pid

    # Distance from the bottom of the video frame in pixels or percentage of video frame height. Works like CSS. Default is `0`.
    attr_accessor :watermark_bottom

    attr_accessor :watermark_bumpers

    # Height of the watermark image in pixels or percentage of video frame height. Default is no resizing
    attr_accessor :watermark_height

    # Distance from the left of the video frame in pixels or percentage of video frame width. Works like CSS. Default is `0`.
    attr_accessor :watermark_left

    # Distance from the right of the video frame in pixels or percentage of video frame width. Works like CSS. Default is `0`.
    attr_accessor :watermark_right

    # Distance from the top of the video frame in pixels or percentage of video frame height. Works like CSS. Default is `0`.
    attr_accessor :watermark_top

    attr_accessor :watermark_trailers

    # Url of a watermark image.
    attr_accessor :watermark_url

    # Width of the watermark image in pixels or percentage of video frame width. Default is `no resizing`.
    attr_accessor :watermark_width

    # Width in pixels.
    attr_accessor :width

    attr_accessor :x264_options

    attr_accessor :x265_options

    attr_accessor :xdcam_format

    # Enable more sensitive pulldown removal algorithm.
    attr_accessor :tachyon_allow_remove_pulldown

    # If the images you are converting are composited 29.976, but the pulldown pattern was not adhered to when performing the composite, this setting is required to remove combing artifacts. It will also remove combing artifacts related to very poor 3:2 cadence.
    attr_accessor :tachyon_enable_post_pulldown_filter

    attr_accessor :tachyon_media_hint_is_cartoon

    # Remove chroma noise during the analysis of a video.
    attr_accessor :tachyon_media_hint_has_chroma_noise

    # When pulldown is not achieved due to extremely broken cadence, or other factors like highly mixed content or if chroma noise masks motion, the pulldown engine may fall back to de-interlacing rather than removing telecine. If that's a case, a more sensitive pulldown pattern can be used. This algorithm favors inverse telecine and with lower thresholds for triggering pulldown identification, will maximize the number of progressive frames created from the video.
    attr_accessor :tachyon_more_sensitive_remove_pulldown

    attr_accessor :tachyon_allow_add_standard_pd

    # Allows 2:2 (PSF) Insertion. Creates a new series of frames which are based on duplicating the field an interlacing it into top/bottom field. Maintains a film-look.
    attr_accessor :tachyon_allow_add_2_2pd

    # Allows 4:4 Insertion. Repeats each progressive frame twice on output (motion rate is halved). This setting is used when you want to convert to high progressive frame rates (i.e. 50p/59.94p/60p) but want to preserve film qualities (low motion rate, such as 24p).
    attr_accessor :tachyon_allow_add_4_4pd

    # 2:3 Insertion. inserts a standard 2:3 telecine pattern to 23.976p video stream to achieve a 29.97i frame rate
    attr_accessor :tachyon_allow_add_4_6pd

    # Allows Euro Insertion. For field based interpolation rather than pixel-based. This is designed for interlaced or progressive integer frame rate conversions that are being converted to interlaced outputs. This method is valid for 24p to 50i conversions only.
    attr_accessor :tachyon_allow_add_euro_pd

    # Allows Adaptive Insertion. For field-based interpolation rather than using pixel-based interpolation. This algorithm is designed for both integer and non-integer frame rate conversion targets - as long as one of them is a non-integer rate (23.976, 29.97, 59.94, etc). This creates NTSC-PAL conversions clean of motion artifacts at the expense of potential slight stutter. Stutter is most noticeable with material that has smooth and uniform motion.
    attr_accessor :tachyon_allow_add_adaptive_pd

    # This setting determines how much Tachyon will trust motion vectors in the creation of new images
    attr_accessor :tachyon_motion_amount

    # This option specifies the transition region size between fallback areas and motion compensated areas. A larger fallback size allows more blending (feathering) to occur between the regions.
    attr_accessor :tachyon_fallback_size

    # This option specifies the size of a motion block.
    attr_accessor :tachyon_mblock_size

    attr_accessor :tachyon_cut_detection_sensitivity

    # Enables the trusted metadata framework.
    attr_accessor :eac3_evolution_enable

    # Selects the type of audio service. **For 1/0 Voiceover will be used when Voiceover/Karaoke is selected. For 2/0 and above Karaoke will be used.
    attr_accessor :eac3_bitstream_mode

    # Applies a 90-degree phase shift to the surround channels; necessary if the output file is being decoded by a Dolby Surround Pro Logic or Pro Logic II decoder.
    attr_accessor :eac3_ninety_degree_phase_shift

    # Attenuates the surround channels by 3 dB before encoding.
    attr_accessor :eac3_three_decibel_attenuation

    # Applies a 120 Hz eighth order lowpass filter to the LFE input prior to encoding.
    attr_accessor :eac3_enable_lfe_low_pass_filter

    # Allows audio that has passed through an A/D conversion stage to be marked as such.
    attr_accessor :eac3_analog_to_digital_converter_type

    attr_accessor :eac3_stereo_downmix_preference

    # Indicates the level shift applied to the center channel when adding to the left and right outputs during a downmix to a Lt/Rt output.
    attr_accessor :eac3_lt_rt_center_mix_level

    # Indicates the level shift applied to the surround channel when adding to the left and right outputs during a downmix to a Lt/Rt output.
    attr_accessor :eac3_lt_rt_surround_mix_level

    # Indicates the level shift applied to the center channel when adding to the left and right outputs during a downmix to a Lo/Ro output.
    attr_accessor :eac3_lo_ro_center_mix_level

    # Indicates the level shift applied to the surround channel when adding to the left and right outputs during a downmix to a Lo/Ro output.
    attr_accessor :eac3_lo_ro_surround_mix_level

    # Indicates whether the audio stream was encoded using Dolby EX.
    attr_accessor :eac3_surround_ex_mode

    # Dynamic Range Control for Line Mode.
    attr_accessor :eac3_drc_line_mode_profile

    # Dynamic Range Control for RF Mode.
    attr_accessor :eac3_drc_rf_mode_profile

    # Represents the volume level of dialog in the audio stream which can be used by a Dolby Digital decoder. This aids the decoder in matching volume between program sources. Minimum value is 1, maximum is 31.
    attr_accessor :eac3_dialog_normalization

    attr_accessor :eac3_room_type

    # Minimum value is 80, maximum is 111.
    attr_accessor :eac3_mixing_level

    # Indicates whether the encoded bitstream is copyright protected.
    attr_accessor :eac3_copyright_protected

    # Indicates whether the encoded bitstream is the master version, or a copy.
    attr_accessor :eac3_original_bitstream

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'advanced_fps_conversion' => :'advanced_fps_conversion',
        :'aspect_mode' => :'aspect_mode',
        :'aspect_ratio' => :'aspect_ratio',
        :'audio_bitrate' => :'audio_bitrate',
        :'audio_channels' => :'audio_channels',
        :'audio_channels_layout' => :'audio_channels_layout',
        :'audio_channels_per_track' => :'audio_channels_per_track',
        :'audio_codec' => :'audio_codec',
        :'audio_format' => :'audio_format',
        :'audio_map' => :'audio_map',
        :'audio_pid' => :'audio_pid',
        :'audio_profile' => :'audio_profile',
        :'audio_sample_rate' => :'audio_sample_rate',
        :'audio_stream_id' => :'audio_stream_id',
        :'audio_streams' => :'audio_streams',
        :'avcintra_class' => :'avcintra_class',
        :'buffer_size' => :'buffer_size',
        :'buffer_size_in_packets' => :'buffer_size_in_packets',
        :'bumpers' => :'bumpers',
        :'byte_range_requests' => :'byte_range_requests',
        :'clip_end' => :'clip_end',
        :'clip_length' => :'clip_length',
        :'clip_offset' => :'clip_offset',
        :'closed_captions' => :'closed_captions',
        :'color_metadata' => :'color_metadata',
        :'created_at' => :'created_at',
        :'crop_input_bottom' => :'crop_input_bottom',
        :'crop_input_height' => :'crop_input_height',
        :'crop_input_left' => :'crop_input_left',
        :'crop_input_right' => :'crop_input_right',
        :'crop_input_top' => :'crop_input_top',
        :'crop_input_width' => :'crop_input_width',
        :'dash_profile' => :'dash_profile',
        :'deinterlace' => :'deinterlace',
        :'deinterlace_frames' => :'deinterlace_frames',
        :'description' => :'description',
        :'dnxhd_type' => :'dnxhd_type',
        :'encryption' => :'encryption',
        :'extname' => :'extname',
        :'fps' => :'fps',
        :'frame_count' => :'frame_count',
        :'frame_interval' => :'frame_interval',
        :'frame_offsets' => :'frame_offsets',
        :'h264_level' => :'h264_level',
        :'h264_profile' => :'h264_profile',
        :'h264_tune' => :'h264_tune',
        :'height' => :'height',
        :'id' => :'id',
        :'imx_type' => :'imx_type',
        :'inputs' => :'inputs',
        :'interlace' => :'interlace',
        :'keyframe_interval' => :'keyframe_interval',
        :'keyframe_rate' => :'keyframe_rate',
        :'lang' => :'lang',
        :'max_rate' => :'max_rate',
        :'merge_audio_streams' => :'merge_audio_streams',
        :'mute_audio_tracks' => :'mute_audio_tracks',
        :'name' => :'name',
        :'outputs' => :'outputs',
        :'outputs_path_format' => :'outputs_path_format',
        :'playlist_type' => :'playlist_type',
        :'pmt_pid' => :'pmt_pid',
        :'preset_name' => :'preset_name',
        :'prores_format' => :'prores_format',
        :'segment_time' => :'segment_time',
        :'stack' => :'stack',
        :'telestream_block_size' => :'telestream_block_size',
        :'telestream_blur_scaler' => :'telestream_blur_scaler',
        :'telestream_cost_scaler' => :'telestream_cost_scaler',
        :'telestream_search_length_scaler' => :'telestream_search_length_scaler',
        :'telestream_subpel_mode' => :'telestream_subpel_mode',
        :'time_code' => :'time_code',
        :'title' => :'title',
        :'trailers' => :'trailers',
        :'transport_rate' => :'transport_rate',
        :'ts_pids' => :'ts_pids',
        :'updated_at' => :'updated_at',
        :'upscale' => :'upscale',
        :'use_editlist' => :'use_editlist',
        :'variants' => :'variants',
        :'video_bitrate' => :'video_bitrate',
        :'video_pid' => :'video_pid',
        :'watermark_bottom' => :'watermark_bottom',
        :'watermark_bumpers' => :'watermark_bumpers',
        :'watermark_height' => :'watermark_height',
        :'watermark_left' => :'watermark_left',
        :'watermark_right' => :'watermark_right',
        :'watermark_top' => :'watermark_top',
        :'watermark_trailers' => :'watermark_trailers',
        :'watermark_url' => :'watermark_url',
        :'watermark_width' => :'watermark_width',
        :'width' => :'width',
        :'x264_options' => :'x264_options',
        :'x265_options' => :'x265_options',
        :'xdcam_format' => :'xdcam_format',
        :'tachyon_allow_remove_pulldown' => :'tachyon_allow_remove_pulldown',
        :'tachyon_enable_post_pulldown_filter' => :'tachyon_enable_post_pulldown_filter',
        :'tachyon_media_hint_is_cartoon' => :'tachyon_media_hint_is_cartoon',
        :'tachyon_media_hint_has_chroma_noise' => :'tachyon_media_hint_has_chroma_noise',
        :'tachyon_more_sensitive_remove_pulldown' => :'tachyon_more_sensitive_remove_pulldown',
        :'tachyon_allow_add_standard_pd' => :'tachyon_allow_add_standard_pd',
        :'tachyon_allow_add_2_2pd' => :'tachyon_allow_add_2_2pd',
        :'tachyon_allow_add_4_4pd' => :'tachyon_allow_add_4_4pd',
        :'tachyon_allow_add_4_6pd' => :'tachyon_allow_add_4_6pd',
        :'tachyon_allow_add_euro_pd' => :'tachyon_allow_add_euro_pd',
        :'tachyon_allow_add_adaptive_pd' => :'tachyon_allow_add_adaptive_pd',
        :'tachyon_motion_amount' => :'tachyon_motion_amount',
        :'tachyon_fallback_size' => :'tachyon_fallback_size',
        :'tachyon_mblock_size' => :'tachyon_mblock_size',
        :'tachyon_cut_detection_sensitivity' => :'tachyon_cut_detection_sensitivity',
        :'eac3_evolution_enable' => :'eac3_evolution_enable',
        :'eac3_bitstream_mode' => :'eac3_bitstream_mode',
        :'eac3_ninety_degree_phase_shift' => :'eac3_ninety_degree_phase_shift',
        :'eac3_three_decibel_attenuation' => :'eac3_three_decibel_attenuation',
        :'eac3_enable_lfe_low_pass_filter' => :'eac3_enable_lfe_low_pass_filter',
        :'eac3_analog_to_digital_converter_type' => :'eac3_analog_to_digital_converter_type',
        :'eac3_stereo_downmix_preference' => :'eac3_stereo_downmix_preference',
        :'eac3_lt_rt_center_mix_level' => :'eac3_lt_rt_center_mix_level',
        :'eac3_lt_rt_surround_mix_level' => :'eac3_lt_rt_surround_mix_level',
        :'eac3_lo_ro_center_mix_level' => :'eac3_lo_ro_center_mix_level',
        :'eac3_lo_ro_surround_mix_level' => :'eac3_lo_ro_surround_mix_level',
        :'eac3_surround_ex_mode' => :'eac3_surround_ex_mode',
        :'eac3_drc_line_mode_profile' => :'eac3_drc_line_mode_profile',
        :'eac3_drc_rf_mode_profile' => :'eac3_drc_rf_mode_profile',
        :'eac3_dialog_normalization' => :'eac3_dialog_normalization',
        :'eac3_room_type' => :'eac3_room_type',
        :'eac3_mixing_level' => :'eac3_mixing_level',
        :'eac3_copyright_protected' => :'eac3_copyright_protected',
        :'eac3_original_bitstream' => :'eac3_original_bitstream'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'advanced_fps_conversion' => :'String',
        :'aspect_mode' => :'String',
        :'aspect_ratio' => :'String',
        :'audio_bitrate' => :'Integer',
        :'audio_channels' => :'Integer',
        :'audio_channels_layout' => :'String',
        :'audio_channels_per_track' => :'Integer',
        :'audio_codec' => :'String',
        :'audio_format' => :'String',
        :'audio_map' => :'String',
        :'audio_pid' => :'String',
        :'audio_profile' => :'String',
        :'audio_sample_rate' => :'String',
        :'audio_stream_id' => :'Integer',
        :'audio_streams' => :'Integer',
        :'avcintra_class' => :'String',
        :'buffer_size' => :'String',
        :'buffer_size_in_packets' => :'String',
        :'bumpers' => :'String',
        :'byte_range_requests' => :'BOOLEAN',
        :'clip_end' => :'String',
        :'clip_length' => :'String',
        :'clip_offset' => :'String',
        :'closed_captions' => :'String',
        :'color_metadata' => :'BOOLEAN',
        :'created_at' => :'String',
        :'crop_input_bottom' => :'String',
        :'crop_input_height' => :'String',
        :'crop_input_left' => :'String',
        :'crop_input_right' => :'String',
        :'crop_input_top' => :'String',
        :'crop_input_width' => :'String',
        :'dash_profile' => :'String',
        :'deinterlace' => :'String',
        :'deinterlace_frames' => :'String',
        :'description' => :'String',
        :'dnxhd_type' => :'String',
        :'encryption' => :'BOOLEAN',
        :'extname' => :'String',
        :'fps' => :'String',
        :'frame_count' => :'String',
        :'frame_interval' => :'String',
        :'frame_offsets' => :'String',
        :'h264_level' => :'String',
        :'h264_profile' => :'String',
        :'h264_tune' => :'String',
        :'height' => :'String',
        :'id' => :'String',
        :'imx_type' => :'String',
        :'inputs' => :'String',
        :'interlace' => :'String',
        :'keyframe_interval' => :'String',
        :'keyframe_rate' => :'String',
        :'lang' => :'String',
        :'max_rate' => :'String',
        :'merge_audio_streams' => :'String',
        :'mute_audio_tracks' => :'BOOLEAN',
        :'name' => :'String',
        :'outputs' => :'String',
        :'outputs_path_format' => :'String',
        :'playlist_type' => :'String',
        :'pmt_pid' => :'String',
        :'preset_name' => :'String',
        :'prores_format' => :'String',
        :'segment_time' => :'Integer',
        :'stack' => :'String',
        :'telestream_block_size' => :'String',
        :'telestream_blur_scaler' => :'Float',
        :'telestream_cost_scaler' => :'Float',
        :'telestream_search_length_scaler' => :'Integer',
        :'telestream_subpel_mode' => :'BOOLEAN',
        :'time_code' => :'String',
        :'title' => :'String',
        :'trailers' => :'String',
        :'transport_rate' => :'String',
        :'ts_pids' => :'String',
        :'updated_at' => :'String',
        :'upscale' => :'BOOLEAN',
        :'use_editlist' => :'BOOLEAN',
        :'variants' => :'String',
        :'video_bitrate' => :'String',
        :'video_pid' => :'String',
        :'watermark_bottom' => :'String',
        :'watermark_bumpers' => :'BOOLEAN',
        :'watermark_height' => :'String',
        :'watermark_left' => :'String',
        :'watermark_right' => :'String',
        :'watermark_top' => :'String',
        :'watermark_trailers' => :'BOOLEAN',
        :'watermark_url' => :'String',
        :'watermark_width' => :'String',
        :'width' => :'String',
        :'x264_options' => :'String',
        :'x265_options' => :'String',
        :'xdcam_format' => :'String',
        :'tachyon_allow_remove_pulldown' => :'BOOLEAN',
        :'tachyon_enable_post_pulldown_filter' => :'BOOLEAN',
        :'tachyon_media_hint_is_cartoon' => :'BOOLEAN',
        :'tachyon_media_hint_has_chroma_noise' => :'BOOLEAN',
        :'tachyon_more_sensitive_remove_pulldown' => :'BOOLEAN',
        :'tachyon_allow_add_standard_pd' => :'BOOLEAN',
        :'tachyon_allow_add_2_2pd' => :'BOOLEAN',
        :'tachyon_allow_add_4_4pd' => :'BOOLEAN',
        :'tachyon_allow_add_4_6pd' => :'BOOLEAN',
        :'tachyon_allow_add_euro_pd' => :'BOOLEAN',
        :'tachyon_allow_add_adaptive_pd' => :'BOOLEAN',
        :'tachyon_motion_amount' => :'String',
        :'tachyon_fallback_size' => :'String',
        :'tachyon_mblock_size' => :'String',
        :'tachyon_cut_detection_sensitivity' => :'Float',
        :'eac3_evolution_enable' => :'BOOLEAN',
        :'eac3_bitstream_mode' => :'String',
        :'eac3_ninety_degree_phase_shift' => :'BOOLEAN',
        :'eac3_three_decibel_attenuation' => :'BOOLEAN',
        :'eac3_enable_lfe_low_pass_filter' => :'BOOLEAN',
        :'eac3_analog_to_digital_converter_type' => :'String',
        :'eac3_stereo_downmix_preference' => :'String',
        :'eac3_lt_rt_center_mix_level' => :'String',
        :'eac3_lt_rt_surround_mix_level' => :'String',
        :'eac3_lo_ro_center_mix_level' => :'String',
        :'eac3_lo_ro_surround_mix_level' => :'String',
        :'eac3_surround_ex_mode' => :'String',
        :'eac3_drc_line_mode_profile' => :'String',
        :'eac3_drc_rf_mode_profile' => :'String',
        :'eac3_dialog_normalization' => :'Integer',
        :'eac3_room_type' => :'String',
        :'eac3_mixing_level' => :'Integer',
        :'eac3_copyright_protected' => :'BOOLEAN',
        :'eac3_original_bitstream' => :'BOOLEAN'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'advanced_fps_conversion')
        self.advanced_fps_conversion = attributes[:'advanced_fps_conversion']
      end

      if attributes.has_key?(:'aspect_mode')
        self.aspect_mode = attributes[:'aspect_mode']
      end

      if attributes.has_key?(:'aspect_ratio')
        self.aspect_ratio = attributes[:'aspect_ratio']
      end

      if attributes.has_key?(:'audio_bitrate')
        self.audio_bitrate = attributes[:'audio_bitrate']
      end

      if attributes.has_key?(:'audio_channels')
        self.audio_channels = attributes[:'audio_channels']
      end

      if attributes.has_key?(:'audio_channels_layout')
        self.audio_channels_layout = attributes[:'audio_channels_layout']
      end

      if attributes.has_key?(:'audio_channels_per_track')
        self.audio_channels_per_track = attributes[:'audio_channels_per_track']
      end

      if attributes.has_key?(:'audio_codec')
        self.audio_codec = attributes[:'audio_codec']
      end

      if attributes.has_key?(:'audio_format')
        self.audio_format = attributes[:'audio_format']
      end

      if attributes.has_key?(:'audio_map')
        self.audio_map = attributes[:'audio_map']
      end

      if attributes.has_key?(:'audio_pid')
        self.audio_pid = attributes[:'audio_pid']
      end

      if attributes.has_key?(:'audio_profile')
        self.audio_profile = attributes[:'audio_profile']
      end

      if attributes.has_key?(:'audio_sample_rate')
        self.audio_sample_rate = attributes[:'audio_sample_rate']
      end

      if attributes.has_key?(:'audio_stream_id')
        self.audio_stream_id = attributes[:'audio_stream_id']
      end

      if attributes.has_key?(:'audio_streams')
        self.audio_streams = attributes[:'audio_streams']
      end

      if attributes.has_key?(:'avcintra_class')
        self.avcintra_class = attributes[:'avcintra_class']
      end

      if attributes.has_key?(:'buffer_size')
        self.buffer_size = attributes[:'buffer_size']
      end

      if attributes.has_key?(:'buffer_size_in_packets')
        self.buffer_size_in_packets = attributes[:'buffer_size_in_packets']
      end

      if attributes.has_key?(:'bumpers')
        self.bumpers = attributes[:'bumpers']
      end

      if attributes.has_key?(:'byte_range_requests')
        self.byte_range_requests = attributes[:'byte_range_requests']
      end

      if attributes.has_key?(:'clip_end')
        self.clip_end = attributes[:'clip_end']
      end

      if attributes.has_key?(:'clip_length')
        self.clip_length = attributes[:'clip_length']
      end

      if attributes.has_key?(:'clip_offset')
        self.clip_offset = attributes[:'clip_offset']
      end

      if attributes.has_key?(:'closed_captions')
        self.closed_captions = attributes[:'closed_captions']
      end

      if attributes.has_key?(:'color_metadata')
        self.color_metadata = attributes[:'color_metadata']
      end

      if attributes.has_key?(:'created_at')
        self.created_at = attributes[:'created_at']
      end

      if attributes.has_key?(:'crop_input_bottom')
        self.crop_input_bottom = attributes[:'crop_input_bottom']
      end

      if attributes.has_key?(:'crop_input_height')
        self.crop_input_height = attributes[:'crop_input_height']
      end

      if attributes.has_key?(:'crop_input_left')
        self.crop_input_left = attributes[:'crop_input_left']
      end

      if attributes.has_key?(:'crop_input_right')
        self.crop_input_right = attributes[:'crop_input_right']
      end

      if attributes.has_key?(:'crop_input_top')
        self.crop_input_top = attributes[:'crop_input_top']
      end

      if attributes.has_key?(:'crop_input_width')
        self.crop_input_width = attributes[:'crop_input_width']
      end

      if attributes.has_key?(:'dash_profile')
        self.dash_profile = attributes[:'dash_profile']
      end

      if attributes.has_key?(:'deinterlace')
        self.deinterlace = attributes[:'deinterlace']
      end

      if attributes.has_key?(:'deinterlace_frames')
        self.deinterlace_frames = attributes[:'deinterlace_frames']
      end

      if attributes.has_key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.has_key?(:'dnxhd_type')
        self.dnxhd_type = attributes[:'dnxhd_type']
      end

      if attributes.has_key?(:'encryption')
        self.encryption = attributes[:'encryption']
      end

      if attributes.has_key?(:'extname')
        self.extname = attributes[:'extname']
      end

      if attributes.has_key?(:'fps')
        self.fps = attributes[:'fps']
      end

      if attributes.has_key?(:'frame_count')
        self.frame_count = attributes[:'frame_count']
      end

      if attributes.has_key?(:'frame_interval')
        self.frame_interval = attributes[:'frame_interval']
      end

      if attributes.has_key?(:'frame_offsets')
        self.frame_offsets = attributes[:'frame_offsets']
      end

      if attributes.has_key?(:'h264_level')
        self.h264_level = attributes[:'h264_level']
      end

      if attributes.has_key?(:'h264_profile')
        self.h264_profile = attributes[:'h264_profile']
      end

      if attributes.has_key?(:'h264_tune')
        self.h264_tune = attributes[:'h264_tune']
      end

      if attributes.has_key?(:'height')
        self.height = attributes[:'height']
      end

      if attributes.has_key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.has_key?(:'imx_type')
        self.imx_type = attributes[:'imx_type']
      end

      if attributes.has_key?(:'inputs')
        self.inputs = attributes[:'inputs']
      end

      if attributes.has_key?(:'interlace')
        self.interlace = attributes[:'interlace']
      end

      if attributes.has_key?(:'keyframe_interval')
        self.keyframe_interval = attributes[:'keyframe_interval']
      end

      if attributes.has_key?(:'keyframe_rate')
        self.keyframe_rate = attributes[:'keyframe_rate']
      end

      if attributes.has_key?(:'lang')
        self.lang = attributes[:'lang']
      end

      if attributes.has_key?(:'max_rate')
        self.max_rate = attributes[:'max_rate']
      end

      if attributes.has_key?(:'merge_audio_streams')
        self.merge_audio_streams = attributes[:'merge_audio_streams']
      end

      if attributes.has_key?(:'mute_audio_tracks')
        self.mute_audio_tracks = attributes[:'mute_audio_tracks']
      end

      if attributes.has_key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.has_key?(:'outputs')
        self.outputs = attributes[:'outputs']
      end

      if attributes.has_key?(:'outputs_path_format')
        self.outputs_path_format = attributes[:'outputs_path_format']
      end

      if attributes.has_key?(:'playlist_type')
        self.playlist_type = attributes[:'playlist_type']
      end

      if attributes.has_key?(:'pmt_pid')
        self.pmt_pid = attributes[:'pmt_pid']
      end

      if attributes.has_key?(:'preset_name')
        self.preset_name = attributes[:'preset_name']
      end

      if attributes.has_key?(:'prores_format')
        self.prores_format = attributes[:'prores_format']
      end

      if attributes.has_key?(:'segment_time')
        self.segment_time = attributes[:'segment_time']
      end

      if attributes.has_key?(:'stack')
        self.stack = attributes[:'stack']
      end

      if attributes.has_key?(:'telestream_block_size')
        self.telestream_block_size = attributes[:'telestream_block_size']
      end

      if attributes.has_key?(:'telestream_blur_scaler')
        self.telestream_blur_scaler = attributes[:'telestream_blur_scaler']
      end

      if attributes.has_key?(:'telestream_cost_scaler')
        self.telestream_cost_scaler = attributes[:'telestream_cost_scaler']
      end

      if attributes.has_key?(:'telestream_search_length_scaler')
        self.telestream_search_length_scaler = attributes[:'telestream_search_length_scaler']
      end

      if attributes.has_key?(:'telestream_subpel_mode')
        self.telestream_subpel_mode = attributes[:'telestream_subpel_mode']
      end

      if attributes.has_key?(:'time_code')
        self.time_code = attributes[:'time_code']
      end

      if attributes.has_key?(:'title')
        self.title = attributes[:'title']
      end

      if attributes.has_key?(:'trailers')
        self.trailers = attributes[:'trailers']
      end

      if attributes.has_key?(:'transport_rate')
        self.transport_rate = attributes[:'transport_rate']
      end

      if attributes.has_key?(:'ts_pids')
        self.ts_pids = attributes[:'ts_pids']
      end

      if attributes.has_key?(:'updated_at')
        self.updated_at = attributes[:'updated_at']
      end

      if attributes.has_key?(:'upscale')
        self.upscale = attributes[:'upscale']
      end

      if attributes.has_key?(:'use_editlist')
        self.use_editlist = attributes[:'use_editlist']
      end

      if attributes.has_key?(:'variants')
        self.variants = attributes[:'variants']
      end

      if attributes.has_key?(:'video_bitrate')
        self.video_bitrate = attributes[:'video_bitrate']
      end

      if attributes.has_key?(:'video_pid')
        self.video_pid = attributes[:'video_pid']
      end

      if attributes.has_key?(:'watermark_bottom')
        self.watermark_bottom = attributes[:'watermark_bottom']
      end

      if attributes.has_key?(:'watermark_bumpers')
        self.watermark_bumpers = attributes[:'watermark_bumpers']
      end

      if attributes.has_key?(:'watermark_height')
        self.watermark_height = attributes[:'watermark_height']
      end

      if attributes.has_key?(:'watermark_left')
        self.watermark_left = attributes[:'watermark_left']
      end

      if attributes.has_key?(:'watermark_right')
        self.watermark_right = attributes[:'watermark_right']
      end

      if attributes.has_key?(:'watermark_top')
        self.watermark_top = attributes[:'watermark_top']
      end

      if attributes.has_key?(:'watermark_trailers')
        self.watermark_trailers = attributes[:'watermark_trailers']
      end

      if attributes.has_key?(:'watermark_url')
        self.watermark_url = attributes[:'watermark_url']
      end

      if attributes.has_key?(:'watermark_width')
        self.watermark_width = attributes[:'watermark_width']
      end

      if attributes.has_key?(:'width')
        self.width = attributes[:'width']
      end

      if attributes.has_key?(:'x264_options')
        self.x264_options = attributes[:'x264_options']
      end

      if attributes.has_key?(:'x265_options')
        self.x265_options = attributes[:'x265_options']
      end

      if attributes.has_key?(:'xdcam_format')
        self.xdcam_format = attributes[:'xdcam_format']
      end

      if attributes.has_key?(:'tachyon_allow_remove_pulldown')
        self.tachyon_allow_remove_pulldown = attributes[:'tachyon_allow_remove_pulldown']
      end

      if attributes.has_key?(:'tachyon_enable_post_pulldown_filter')
        self.tachyon_enable_post_pulldown_filter = attributes[:'tachyon_enable_post_pulldown_filter']
      end

      if attributes.has_key?(:'tachyon_media_hint_is_cartoon')
        self.tachyon_media_hint_is_cartoon = attributes[:'tachyon_media_hint_is_cartoon']
      end

      if attributes.has_key?(:'tachyon_media_hint_has_chroma_noise')
        self.tachyon_media_hint_has_chroma_noise = attributes[:'tachyon_media_hint_has_chroma_noise']
      end

      if attributes.has_key?(:'tachyon_more_sensitive_remove_pulldown')
        self.tachyon_more_sensitive_remove_pulldown = attributes[:'tachyon_more_sensitive_remove_pulldown']
      end

      if attributes.has_key?(:'tachyon_allow_add_standard_pd')
        self.tachyon_allow_add_standard_pd = attributes[:'tachyon_allow_add_standard_pd']
      end

      if attributes.has_key?(:'tachyon_allow_add_2_2pd')
        self.tachyon_allow_add_2_2pd = attributes[:'tachyon_allow_add_2_2pd']
      end

      if attributes.has_key?(:'tachyon_allow_add_4_4pd')
        self.tachyon_allow_add_4_4pd = attributes[:'tachyon_allow_add_4_4pd']
      end

      if attributes.has_key?(:'tachyon_allow_add_4_6pd')
        self.tachyon_allow_add_4_6pd = attributes[:'tachyon_allow_add_4_6pd']
      end

      if attributes.has_key?(:'tachyon_allow_add_euro_pd')
        self.tachyon_allow_add_euro_pd = attributes[:'tachyon_allow_add_euro_pd']
      end

      if attributes.has_key?(:'tachyon_allow_add_adaptive_pd')
        self.tachyon_allow_add_adaptive_pd = attributes[:'tachyon_allow_add_adaptive_pd']
      end

      if attributes.has_key?(:'tachyon_motion_amount')
        self.tachyon_motion_amount = attributes[:'tachyon_motion_amount']
      end

      if attributes.has_key?(:'tachyon_fallback_size')
        self.tachyon_fallback_size = attributes[:'tachyon_fallback_size']
      end

      if attributes.has_key?(:'tachyon_mblock_size')
        self.tachyon_mblock_size = attributes[:'tachyon_mblock_size']
      end

      if attributes.has_key?(:'tachyon_cut_detection_sensitivity')
        self.tachyon_cut_detection_sensitivity = attributes[:'tachyon_cut_detection_sensitivity']
      end

      if attributes.has_key?(:'eac3_evolution_enable')
        self.eac3_evolution_enable = attributes[:'eac3_evolution_enable']
      end

      if attributes.has_key?(:'eac3_bitstream_mode')
        self.eac3_bitstream_mode = attributes[:'eac3_bitstream_mode']
      end

      if attributes.has_key?(:'eac3_ninety_degree_phase_shift')
        self.eac3_ninety_degree_phase_shift = attributes[:'eac3_ninety_degree_phase_shift']
      end

      if attributes.has_key?(:'eac3_three_decibel_attenuation')
        self.eac3_three_decibel_attenuation = attributes[:'eac3_three_decibel_attenuation']
      end

      if attributes.has_key?(:'eac3_enable_lfe_low_pass_filter')
        self.eac3_enable_lfe_low_pass_filter = attributes[:'eac3_enable_lfe_low_pass_filter']
      end

      if attributes.has_key?(:'eac3_analog_to_digital_converter_type')
        self.eac3_analog_to_digital_converter_type = attributes[:'eac3_analog_to_digital_converter_type']
      end

      if attributes.has_key?(:'eac3_stereo_downmix_preference')
        self.eac3_stereo_downmix_preference = attributes[:'eac3_stereo_downmix_preference']
      end

      if attributes.has_key?(:'eac3_lt_rt_center_mix_level')
        self.eac3_lt_rt_center_mix_level = attributes[:'eac3_lt_rt_center_mix_level']
      end

      if attributes.has_key?(:'eac3_lt_rt_surround_mix_level')
        self.eac3_lt_rt_surround_mix_level = attributes[:'eac3_lt_rt_surround_mix_level']
      end

      if attributes.has_key?(:'eac3_lo_ro_center_mix_level')
        self.eac3_lo_ro_center_mix_level = attributes[:'eac3_lo_ro_center_mix_level']
      end

      if attributes.has_key?(:'eac3_lo_ro_surround_mix_level')
        self.eac3_lo_ro_surround_mix_level = attributes[:'eac3_lo_ro_surround_mix_level']
      end

      if attributes.has_key?(:'eac3_surround_ex_mode')
        self.eac3_surround_ex_mode = attributes[:'eac3_surround_ex_mode']
      end

      if attributes.has_key?(:'eac3_drc_line_mode_profile')
        self.eac3_drc_line_mode_profile = attributes[:'eac3_drc_line_mode_profile']
      end

      if attributes.has_key?(:'eac3_drc_rf_mode_profile')
        self.eac3_drc_rf_mode_profile = attributes[:'eac3_drc_rf_mode_profile']
      end

      if attributes.has_key?(:'eac3_dialog_normalization')
        self.eac3_dialog_normalization = attributes[:'eac3_dialog_normalization']
      end

      if attributes.has_key?(:'eac3_room_type')
        self.eac3_room_type = attributes[:'eac3_room_type']
      end

      if attributes.has_key?(:'eac3_mixing_level')
        self.eac3_mixing_level = attributes[:'eac3_mixing_level']
      end

      if attributes.has_key?(:'eac3_copyright_protected')
        self.eac3_copyright_protected = attributes[:'eac3_copyright_protected']
      end

      if attributes.has_key?(:'eac3_original_bitstream')
        self.eac3_original_bitstream = attributes[:'eac3_original_bitstream']
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      advanced_fps_conversion_validator = EnumAttributeValidator.new('String', ["telestream", "tachyon"])
      return false unless advanced_fps_conversion_validator.valid?(@advanced_fps_conversion)
      aspect_mode_validator = EnumAttributeValidator.new('String', ["preserve", "constrain", "letterbox", "pad", "fill (crop)", "stretch", "center"])
      return false unless aspect_mode_validator.valid?(@aspect_mode)
      audio_channels_layout_validator = EnumAttributeValidator.new('String', ["1.0", "2.0", "2.1", "3.0", "3.0(back)", "3.1", "4.0", "4.1", "quad", "5.0", "5.0(side)", "5.1(side)", "6.0", "6.1", "7.0", "7.1", "mono", "stereo"])
      return false unless audio_channels_layout_validator.valid?(@audio_channels_layout)
      audio_format_validator = EnumAttributeValidator.new('String', ["pcm_s24le", "pcm_s16le"])
      return false unless audio_format_validator.valid?(@audio_format)
      avcintra_class_validator = EnumAttributeValidator.new('String', ["50", "100"])
      return false unless avcintra_class_validator.valid?(@avcintra_class)
      closed_captions_validator = EnumAttributeValidator.new('String', ["add", "burn"])
      return false unless closed_captions_validator.valid?(@closed_captions)
      deinterlace_validator = EnumAttributeValidator.new('String', ["keep_fps", "double_fps"])
      return false unless deinterlace_validator.valid?(@deinterlace)
      dnxhd_type_validator = EnumAttributeValidator.new('String', ["36", "45", "60", "75", "90", "90x", "110", "115", "120", "145", "175x", "175", "185x", "185", "220x", "220"])
      return false unless dnxhd_type_validator.valid?(@dnxhd_type)
      h264_level_validator = EnumAttributeValidator.new('String', ["1.0", "1b", "1.1", "1.2", "1.3", "2.0", "2.1", "2.2", "3.0", "3.1", "3.2", "4.0", "4.1", "4.2", "5.0", "5.1"])
      return false unless h264_level_validator.valid?(@h264_level)
      h264_profile_validator = EnumAttributeValidator.new('String', ["baseline", "main", "high", "high10", "high422", "high444"])
      return false unless h264_profile_validator.valid?(@h264_profile)
      h264_tune_validator = EnumAttributeValidator.new('String', ["film", "animation", "grain", "psnr", "ssim", "fastdecode", "zerolatency"])
      return false unless h264_tune_validator.valid?(@h264_tune)
      playlist_type_validator = EnumAttributeValidator.new('String', ["iframe", "iframe-only"])
      return false unless playlist_type_validator.valid?(@playlist_type)
      telestream_block_size_validator = EnumAttributeValidator.new('String', ["16x16", "24x24", "32x32"])
      return false unless telestream_block_size_validator.valid?(@telestream_block_size)
      tachyon_motion_amount_validator = EnumAttributeValidator.new('String', ["xlow", "low", "medium", "high", "xhigh", "auto"])
      return false unless tachyon_motion_amount_validator.valid?(@tachyon_motion_amount)
      tachyon_fallback_size_validator = EnumAttributeValidator.new('String', ["small", "medium", "large", "xlarge", "auto"])
      return false unless tachyon_fallback_size_validator.valid?(@tachyon_fallback_size)
      tachyon_mblock_size_validator = EnumAttributeValidator.new('String', ["mb16", "mb32", "mb64", "mb128", "mb256", "auto"])
      return false unless tachyon_mblock_size_validator.valid?(@tachyon_mblock_size)
      eac3_bitstream_mode_validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2", "m3", "m4", "m5", "m6", "m7"])
      return false unless eac3_bitstream_mode_validator.valid?(@eac3_bitstream_mode)
      eac3_analog_to_digital_converter_type_validator = EnumAttributeValidator.new('String', ["standard", "hdcd"])
      return false unless eac3_analog_to_digital_converter_type_validator.valid?(@eac3_analog_to_digital_converter_type)
      eac3_stereo_downmix_preference_validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2", "m3"])
      return false unless eac3_stereo_downmix_preference_validator.valid?(@eac3_stereo_downmix_preference)
      eac3_lt_rt_center_mix_level_validator = EnumAttributeValidator.new('String', ["c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7"])
      return false unless eac3_lt_rt_center_mix_level_validator.valid?(@eac3_lt_rt_center_mix_level)
      eac3_lt_rt_surround_mix_level_validator = EnumAttributeValidator.new('String', ["c3", "c4", "c5", "c6", "c7"])
      return false unless eac3_lt_rt_surround_mix_level_validator.valid?(@eac3_lt_rt_surround_mix_level)
      eac3_lo_ro_center_mix_level_validator = EnumAttributeValidator.new('String', ["c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7"])
      return false unless eac3_lo_ro_center_mix_level_validator.valid?(@eac3_lo_ro_center_mix_level)
      eac3_lo_ro_surround_mix_level_validator = EnumAttributeValidator.new('String', ["c3", "c4", "c5", "c6", "c7"])
      return false unless eac3_lo_ro_surround_mix_level_validator.valid?(@eac3_lo_ro_surround_mix_level)
      eac3_surround_ex_mode_validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2"])
      return false unless eac3_surround_ex_mode_validator.valid?(@eac3_surround_ex_mode)
      eac3_drc_line_mode_profile_validator = EnumAttributeValidator.new('String', ["p0", "p1", "p2", "p3", "p4", "p5"])
      return false unless eac3_drc_line_mode_profile_validator.valid?(@eac3_drc_line_mode_profile)
      eac3_drc_rf_mode_profile_validator = EnumAttributeValidator.new('String', ["p0", "p1", "p2", "p3", "p4", "p5"])
      return false unless eac3_drc_rf_mode_profile_validator.valid?(@eac3_drc_rf_mode_profile)
      eac3_room_type_validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2"])
      return false unless eac3_room_type_validator.valid?(@eac3_room_type)
      return true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] advanced_fps_conversion Object to be assigned
    def advanced_fps_conversion=(advanced_fps_conversion)
      validator = EnumAttributeValidator.new('String', ["telestream", "tachyon"])
      unless validator.valid?(advanced_fps_conversion)
        fail ArgumentError, "invalid value for 'advanced_fps_conversion', must be one of #{validator.allowable_values}."
      end
      @advanced_fps_conversion = advanced_fps_conversion
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] aspect_mode Object to be assigned
    def aspect_mode=(aspect_mode)
      validator = EnumAttributeValidator.new('String', ["preserve", "constrain", "letterbox", "pad", "fill (crop)", "stretch", "center"])
      unless validator.valid?(aspect_mode)
        fail ArgumentError, "invalid value for 'aspect_mode', must be one of #{validator.allowable_values}."
      end
      @aspect_mode = aspect_mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] audio_channels_layout Object to be assigned
    def audio_channels_layout=(audio_channels_layout)
      validator = EnumAttributeValidator.new('String', ["1.0", "2.0", "2.1", "3.0", "3.0(back)", "3.1", "4.0", "4.1", "quad", "5.0", "5.0(side)", "5.1(side)", "6.0", "6.1", "7.0", "7.1", "mono", "stereo"])
      unless validator.valid?(audio_channels_layout)
        fail ArgumentError, "invalid value for 'audio_channels_layout', must be one of #{validator.allowable_values}."
      end
      @audio_channels_layout = audio_channels_layout
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] audio_format Object to be assigned
    def audio_format=(audio_format)
      validator = EnumAttributeValidator.new('String', ["pcm_s24le", "pcm_s16le"])
      unless validator.valid?(audio_format)
        fail ArgumentError, "invalid value for 'audio_format', must be one of #{validator.allowable_values}."
      end
      @audio_format = audio_format
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] avcintra_class Object to be assigned
    def avcintra_class=(avcintra_class)
      validator = EnumAttributeValidator.new('String', ["50", "100"])
      unless validator.valid?(avcintra_class)
        fail ArgumentError, "invalid value for 'avcintra_class', must be one of #{validator.allowable_values}."
      end
      @avcintra_class = avcintra_class
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] closed_captions Object to be assigned
    def closed_captions=(closed_captions)
      validator = EnumAttributeValidator.new('String', ["add", "burn"])
      unless validator.valid?(closed_captions)
        fail ArgumentError, "invalid value for 'closed_captions', must be one of #{validator.allowable_values}."
      end
      @closed_captions = closed_captions
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] deinterlace Object to be assigned
    def deinterlace=(deinterlace)
      validator = EnumAttributeValidator.new('String', ["keep_fps", "double_fps"])
      unless validator.valid?(deinterlace)
        fail ArgumentError, "invalid value for 'deinterlace', must be one of #{validator.allowable_values}."
      end
      @deinterlace = deinterlace
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] dnxhd_type Object to be assigned
    def dnxhd_type=(dnxhd_type)
      validator = EnumAttributeValidator.new('String', ["36", "45", "60", "75", "90", "90x", "110", "115", "120", "145", "175x", "175", "185x", "185", "220x", "220"])
      unless validator.valid?(dnxhd_type)
        fail ArgumentError, "invalid value for 'dnxhd_type', must be one of #{validator.allowable_values}."
      end
      @dnxhd_type = dnxhd_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] h264_level Object to be assigned
    def h264_level=(h264_level)
      validator = EnumAttributeValidator.new('String', ["1.0", "1b", "1.1", "1.2", "1.3", "2.0", "2.1", "2.2", "3.0", "3.1", "3.2", "4.0", "4.1", "4.2", "5.0", "5.1"])
      unless validator.valid?(h264_level)
        fail ArgumentError, "invalid value for 'h264_level', must be one of #{validator.allowable_values}."
      end
      @h264_level = h264_level
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] h264_profile Object to be assigned
    def h264_profile=(h264_profile)
      validator = EnumAttributeValidator.new('String', ["baseline", "main", "high", "high10", "high422", "high444"])
      unless validator.valid?(h264_profile)
        fail ArgumentError, "invalid value for 'h264_profile', must be one of #{validator.allowable_values}."
      end
      @h264_profile = h264_profile
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] h264_tune Object to be assigned
    def h264_tune=(h264_tune)
      validator = EnumAttributeValidator.new('String', ["film", "animation", "grain", "psnr", "ssim", "fastdecode", "zerolatency"])
      unless validator.valid?(h264_tune)
        fail ArgumentError, "invalid value for 'h264_tune', must be one of #{validator.allowable_values}."
      end
      @h264_tune = h264_tune
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] playlist_type Object to be assigned
    def playlist_type=(playlist_type)
      validator = EnumAttributeValidator.new('String', ["iframe", "iframe-only"])
      unless validator.valid?(playlist_type)
        fail ArgumentError, "invalid value for 'playlist_type', must be one of #{validator.allowable_values}."
      end
      @playlist_type = playlist_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] telestream_block_size Object to be assigned
    def telestream_block_size=(telestream_block_size)
      validator = EnumAttributeValidator.new('String', ["16x16", "24x24", "32x32"])
      unless validator.valid?(telestream_block_size)
        fail ArgumentError, "invalid value for 'telestream_block_size', must be one of #{validator.allowable_values}."
      end
      @telestream_block_size = telestream_block_size
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tachyon_motion_amount Object to be assigned
    def tachyon_motion_amount=(tachyon_motion_amount)
      validator = EnumAttributeValidator.new('String', ["xlow", "low", "medium", "high", "xhigh", "auto"])
      unless validator.valid?(tachyon_motion_amount)
        fail ArgumentError, "invalid value for 'tachyon_motion_amount', must be one of #{validator.allowable_values}."
      end
      @tachyon_motion_amount = tachyon_motion_amount
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tachyon_fallback_size Object to be assigned
    def tachyon_fallback_size=(tachyon_fallback_size)
      validator = EnumAttributeValidator.new('String', ["small", "medium", "large", "xlarge", "auto"])
      unless validator.valid?(tachyon_fallback_size)
        fail ArgumentError, "invalid value for 'tachyon_fallback_size', must be one of #{validator.allowable_values}."
      end
      @tachyon_fallback_size = tachyon_fallback_size
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tachyon_mblock_size Object to be assigned
    def tachyon_mblock_size=(tachyon_mblock_size)
      validator = EnumAttributeValidator.new('String', ["mb16", "mb32", "mb64", "mb128", "mb256", "auto"])
      unless validator.valid?(tachyon_mblock_size)
        fail ArgumentError, "invalid value for 'tachyon_mblock_size', must be one of #{validator.allowable_values}."
      end
      @tachyon_mblock_size = tachyon_mblock_size
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_bitstream_mode Object to be assigned
    def eac3_bitstream_mode=(eac3_bitstream_mode)
      validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2", "m3", "m4", "m5", "m6", "m7"])
      unless validator.valid?(eac3_bitstream_mode)
        fail ArgumentError, "invalid value for 'eac3_bitstream_mode', must be one of #{validator.allowable_values}."
      end
      @eac3_bitstream_mode = eac3_bitstream_mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_analog_to_digital_converter_type Object to be assigned
    def eac3_analog_to_digital_converter_type=(eac3_analog_to_digital_converter_type)
      validator = EnumAttributeValidator.new('String', ["standard", "hdcd"])
      unless validator.valid?(eac3_analog_to_digital_converter_type)
        fail ArgumentError, "invalid value for 'eac3_analog_to_digital_converter_type', must be one of #{validator.allowable_values}."
      end
      @eac3_analog_to_digital_converter_type = eac3_analog_to_digital_converter_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_stereo_downmix_preference Object to be assigned
    def eac3_stereo_downmix_preference=(eac3_stereo_downmix_preference)
      validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2", "m3"])
      unless validator.valid?(eac3_stereo_downmix_preference)
        fail ArgumentError, "invalid value for 'eac3_stereo_downmix_preference', must be one of #{validator.allowable_values}."
      end
      @eac3_stereo_downmix_preference = eac3_stereo_downmix_preference
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_lt_rt_center_mix_level Object to be assigned
    def eac3_lt_rt_center_mix_level=(eac3_lt_rt_center_mix_level)
      validator = EnumAttributeValidator.new('String', ["c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7"])
      unless validator.valid?(eac3_lt_rt_center_mix_level)
        fail ArgumentError, "invalid value for 'eac3_lt_rt_center_mix_level', must be one of #{validator.allowable_values}."
      end
      @eac3_lt_rt_center_mix_level = eac3_lt_rt_center_mix_level
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_lt_rt_surround_mix_level Object to be assigned
    def eac3_lt_rt_surround_mix_level=(eac3_lt_rt_surround_mix_level)
      validator = EnumAttributeValidator.new('String', ["c3", "c4", "c5", "c6", "c7"])
      unless validator.valid?(eac3_lt_rt_surround_mix_level)
        fail ArgumentError, "invalid value for 'eac3_lt_rt_surround_mix_level', must be one of #{validator.allowable_values}."
      end
      @eac3_lt_rt_surround_mix_level = eac3_lt_rt_surround_mix_level
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_lo_ro_center_mix_level Object to be assigned
    def eac3_lo_ro_center_mix_level=(eac3_lo_ro_center_mix_level)
      validator = EnumAttributeValidator.new('String', ["c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7"])
      unless validator.valid?(eac3_lo_ro_center_mix_level)
        fail ArgumentError, "invalid value for 'eac3_lo_ro_center_mix_level', must be one of #{validator.allowable_values}."
      end
      @eac3_lo_ro_center_mix_level = eac3_lo_ro_center_mix_level
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_lo_ro_surround_mix_level Object to be assigned
    def eac3_lo_ro_surround_mix_level=(eac3_lo_ro_surround_mix_level)
      validator = EnumAttributeValidator.new('String', ["c3", "c4", "c5", "c6", "c7"])
      unless validator.valid?(eac3_lo_ro_surround_mix_level)
        fail ArgumentError, "invalid value for 'eac3_lo_ro_surround_mix_level', must be one of #{validator.allowable_values}."
      end
      @eac3_lo_ro_surround_mix_level = eac3_lo_ro_surround_mix_level
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_surround_ex_mode Object to be assigned
    def eac3_surround_ex_mode=(eac3_surround_ex_mode)
      validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2"])
      unless validator.valid?(eac3_surround_ex_mode)
        fail ArgumentError, "invalid value for 'eac3_surround_ex_mode', must be one of #{validator.allowable_values}."
      end
      @eac3_surround_ex_mode = eac3_surround_ex_mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_drc_line_mode_profile Object to be assigned
    def eac3_drc_line_mode_profile=(eac3_drc_line_mode_profile)
      validator = EnumAttributeValidator.new('String', ["p0", "p1", "p2", "p3", "p4", "p5"])
      unless validator.valid?(eac3_drc_line_mode_profile)
        fail ArgumentError, "invalid value for 'eac3_drc_line_mode_profile', must be one of #{validator.allowable_values}."
      end
      @eac3_drc_line_mode_profile = eac3_drc_line_mode_profile
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_drc_rf_mode_profile Object to be assigned
    def eac3_drc_rf_mode_profile=(eac3_drc_rf_mode_profile)
      validator = EnumAttributeValidator.new('String', ["p0", "p1", "p2", "p3", "p4", "p5"])
      unless validator.valid?(eac3_drc_rf_mode_profile)
        fail ArgumentError, "invalid value for 'eac3_drc_rf_mode_profile', must be one of #{validator.allowable_values}."
      end
      @eac3_drc_rf_mode_profile = eac3_drc_rf_mode_profile
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] eac3_room_type Object to be assigned
    def eac3_room_type=(eac3_room_type)
      validator = EnumAttributeValidator.new('String', ["m0", "m1", "m2"])
      unless validator.valid?(eac3_room_type)
        fail ArgumentError, "invalid value for 'eac3_room_type', must be one of #{validator.allowable_values}."
      end
      @eac3_room_type = eac3_room_type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          advanced_fps_conversion == o.advanced_fps_conversion &&
          aspect_mode == o.aspect_mode &&
          aspect_ratio == o.aspect_ratio &&
          audio_bitrate == o.audio_bitrate &&
          audio_channels == o.audio_channels &&
          audio_channels_layout == o.audio_channels_layout &&
          audio_channels_per_track == o.audio_channels_per_track &&
          audio_codec == o.audio_codec &&
          audio_format == o.audio_format &&
          audio_map == o.audio_map &&
          audio_pid == o.audio_pid &&
          audio_profile == o.audio_profile &&
          audio_sample_rate == o.audio_sample_rate &&
          audio_stream_id == o.audio_stream_id &&
          audio_streams == o.audio_streams &&
          avcintra_class == o.avcintra_class &&
          buffer_size == o.buffer_size &&
          buffer_size_in_packets == o.buffer_size_in_packets &&
          bumpers == o.bumpers &&
          byte_range_requests == o.byte_range_requests &&
          clip_end == o.clip_end &&
          clip_length == o.clip_length &&
          clip_offset == o.clip_offset &&
          closed_captions == o.closed_captions &&
          color_metadata == o.color_metadata &&
          created_at == o.created_at &&
          crop_input_bottom == o.crop_input_bottom &&
          crop_input_height == o.crop_input_height &&
          crop_input_left == o.crop_input_left &&
          crop_input_right == o.crop_input_right &&
          crop_input_top == o.crop_input_top &&
          crop_input_width == o.crop_input_width &&
          dash_profile == o.dash_profile &&
          deinterlace == o.deinterlace &&
          deinterlace_frames == o.deinterlace_frames &&
          description == o.description &&
          dnxhd_type == o.dnxhd_type &&
          encryption == o.encryption &&
          extname == o.extname &&
          fps == o.fps &&
          frame_count == o.frame_count &&
          frame_interval == o.frame_interval &&
          frame_offsets == o.frame_offsets &&
          h264_level == o.h264_level &&
          h264_profile == o.h264_profile &&
          h264_tune == o.h264_tune &&
          height == o.height &&
          id == o.id &&
          imx_type == o.imx_type &&
          inputs == o.inputs &&
          interlace == o.interlace &&
          keyframe_interval == o.keyframe_interval &&
          keyframe_rate == o.keyframe_rate &&
          lang == o.lang &&
          max_rate == o.max_rate &&
          merge_audio_streams == o.merge_audio_streams &&
          mute_audio_tracks == o.mute_audio_tracks &&
          name == o.name &&
          outputs == o.outputs &&
          outputs_path_format == o.outputs_path_format &&
          playlist_type == o.playlist_type &&
          pmt_pid == o.pmt_pid &&
          preset_name == o.preset_name &&
          prores_format == o.prores_format &&
          segment_time == o.segment_time &&
          stack == o.stack &&
          telestream_block_size == o.telestream_block_size &&
          telestream_blur_scaler == o.telestream_blur_scaler &&
          telestream_cost_scaler == o.telestream_cost_scaler &&
          telestream_search_length_scaler == o.telestream_search_length_scaler &&
          telestream_subpel_mode == o.telestream_subpel_mode &&
          time_code == o.time_code &&
          title == o.title &&
          trailers == o.trailers &&
          transport_rate == o.transport_rate &&
          ts_pids == o.ts_pids &&
          updated_at == o.updated_at &&
          upscale == o.upscale &&
          use_editlist == o.use_editlist &&
          variants == o.variants &&
          video_bitrate == o.video_bitrate &&
          video_pid == o.video_pid &&
          watermark_bottom == o.watermark_bottom &&
          watermark_bumpers == o.watermark_bumpers &&
          watermark_height == o.watermark_height &&
          watermark_left == o.watermark_left &&
          watermark_right == o.watermark_right &&
          watermark_top == o.watermark_top &&
          watermark_trailers == o.watermark_trailers &&
          watermark_url == o.watermark_url &&
          watermark_width == o.watermark_width &&
          width == o.width &&
          x264_options == o.x264_options &&
          x265_options == o.x265_options &&
          xdcam_format == o.xdcam_format &&
          tachyon_allow_remove_pulldown == o.tachyon_allow_remove_pulldown &&
          tachyon_enable_post_pulldown_filter == o.tachyon_enable_post_pulldown_filter &&
          tachyon_media_hint_is_cartoon == o.tachyon_media_hint_is_cartoon &&
          tachyon_media_hint_has_chroma_noise == o.tachyon_media_hint_has_chroma_noise &&
          tachyon_more_sensitive_remove_pulldown == o.tachyon_more_sensitive_remove_pulldown &&
          tachyon_allow_add_standard_pd == o.tachyon_allow_add_standard_pd &&
          tachyon_allow_add_2_2pd == o.tachyon_allow_add_2_2pd &&
          tachyon_allow_add_4_4pd == o.tachyon_allow_add_4_4pd &&
          tachyon_allow_add_4_6pd == o.tachyon_allow_add_4_6pd &&
          tachyon_allow_add_euro_pd == o.tachyon_allow_add_euro_pd &&
          tachyon_allow_add_adaptive_pd == o.tachyon_allow_add_adaptive_pd &&
          tachyon_motion_amount == o.tachyon_motion_amount &&
          tachyon_fallback_size == o.tachyon_fallback_size &&
          tachyon_mblock_size == o.tachyon_mblock_size &&
          tachyon_cut_detection_sensitivity == o.tachyon_cut_detection_sensitivity &&
          eac3_evolution_enable == o.eac3_evolution_enable &&
          eac3_bitstream_mode == o.eac3_bitstream_mode &&
          eac3_ninety_degree_phase_shift == o.eac3_ninety_degree_phase_shift &&
          eac3_three_decibel_attenuation == o.eac3_three_decibel_attenuation &&
          eac3_enable_lfe_low_pass_filter == o.eac3_enable_lfe_low_pass_filter &&
          eac3_analog_to_digital_converter_type == o.eac3_analog_to_digital_converter_type &&
          eac3_stereo_downmix_preference == o.eac3_stereo_downmix_preference &&
          eac3_lt_rt_center_mix_level == o.eac3_lt_rt_center_mix_level &&
          eac3_lt_rt_surround_mix_level == o.eac3_lt_rt_surround_mix_level &&
          eac3_lo_ro_center_mix_level == o.eac3_lo_ro_center_mix_level &&
          eac3_lo_ro_surround_mix_level == o.eac3_lo_ro_surround_mix_level &&
          eac3_surround_ex_mode == o.eac3_surround_ex_mode &&
          eac3_drc_line_mode_profile == o.eac3_drc_line_mode_profile &&
          eac3_drc_rf_mode_profile == o.eac3_drc_rf_mode_profile &&
          eac3_dialog_normalization == o.eac3_dialog_normalization &&
          eac3_room_type == o.eac3_room_type &&
          eac3_mixing_level == o.eac3_mixing_level &&
          eac3_copyright_protected == o.eac3_copyright_protected &&
          eac3_original_bitstream == o.eac3_original_bitstream
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [advanced_fps_conversion, aspect_mode, aspect_ratio, audio_bitrate, audio_channels, audio_channels_layout, audio_channels_per_track, audio_codec, audio_format, audio_map, audio_pid, audio_profile, audio_sample_rate, audio_stream_id, audio_streams, avcintra_class, buffer_size, buffer_size_in_packets, bumpers, byte_range_requests, clip_end, clip_length, clip_offset, closed_captions, color_metadata, created_at, crop_input_bottom, crop_input_height, crop_input_left, crop_input_right, crop_input_top, crop_input_width, dash_profile, deinterlace, deinterlace_frames, description, dnxhd_type, encryption, extname, fps, frame_count, frame_interval, frame_offsets, h264_level, h264_profile, h264_tune, height, id, imx_type, inputs, interlace, keyframe_interval, keyframe_rate, lang, max_rate, merge_audio_streams, mute_audio_tracks, name, outputs, outputs_path_format, playlist_type, pmt_pid, preset_name, prores_format, segment_time, stack, telestream_block_size, telestream_blur_scaler, telestream_cost_scaler, telestream_search_length_scaler, telestream_subpel_mode, time_code, title, trailers, transport_rate, ts_pids, updated_at, upscale, use_editlist, variants, video_bitrate, video_pid, watermark_bottom, watermark_bumpers, watermark_height, watermark_left, watermark_right, watermark_top, watermark_trailers, watermark_url, watermark_width, width, x264_options, x265_options, xdcam_format, tachyon_allow_remove_pulldown, tachyon_enable_post_pulldown_filter, tachyon_media_hint_is_cartoon, tachyon_media_hint_has_chroma_noise, tachyon_more_sensitive_remove_pulldown, tachyon_allow_add_standard_pd, tachyon_allow_add_2_2pd, tachyon_allow_add_4_4pd, tachyon_allow_add_4_6pd, tachyon_allow_add_euro_pd, tachyon_allow_add_adaptive_pd, tachyon_motion_amount, tachyon_fallback_size, tachyon_mblock_size, tachyon_cut_detection_sensitivity, eac3_evolution_enable, eac3_bitstream_mode, eac3_ninety_degree_phase_shift, eac3_three_decibel_attenuation, eac3_enable_lfe_low_pass_filter, eac3_analog_to_digital_converter_type, eac3_stereo_downmix_preference, eac3_lt_rt_center_mix_level, eac3_lt_rt_surround_mix_level, eac3_lo_ro_center_mix_level, eac3_lo_ro_surround_mix_level, eac3_surround_ex_mode, eac3_drc_line_mode_profile, eac3_drc_rf_mode_profile, eac3_dialog_normalization, eac3_room_type, eac3_mixing_level, eac3_copyright_protected, eac3_original_bitstream].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = TelestreamCloud::Flip.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
